// Define & initialise registers
      MOV R0, #arrayData //Address of array data
      LDR R1, arrayLength  
      LSL R1, R1, #2  //Multiply this by 4 (for byte count)
      MOV R2, #0   //outerLoop counter initialized
      // R3 innerLoop counter
      // R4 length of innerLoop
      // R5 spare index into array
      // R6 first in pair
      // R7 second in pair
      // R8 Indicates is any pair swapped on latest pass (of inner loop) 
startOfOuterLoop: 
      MOV R3, #0  //reset inner loop counter to zero
      SUB R4, R1, R2  //set innerloop max to  data length - outerLoopCounter...
      SUB R4, R4, #4  //...minus 4 more
      MOV R8, #0  //reset 'swapped'  for next pass    
innerLoop:
      LDR R6, [R3+R0]  //Load first value (index + base)
      ADD R5, R3, #4 //Generate index for second value in pair
      LDR R7, [R5+R0] //Load second value
      CMP R6, R7
      BGT swap
      B continueInnerLoop
swap: 
      STR R7, [R3+R0]
      STR R6, [R5+R0]
      MOV R8, #1  //Flag that a swap has taken place
continueInnerLoop:
      ADD R3, R3, #4
      CMP R3, R4 //Check if reached the end
      BLT innerLoop
continueOuterLoop:
      CMP R8, #0
      BEQ done  //Terminate if nothing swapped in last inner loop pass
      ADD R2, R2, #4 
      CMP R2, R1
      BGT done
      B startOfOuterLoop
done: HALT

.ALIGN 256 //Just to make data distinct from code in memory view
arrayLength: 10 
arrayData:.WORD 9  //1st element
      .WORD 8
      .WORD 7
      .WORD 6
      .WORD 5
      .WORD 4
      .WORD 3
      .WORD 2
      .WORD 1
      .WORD 0  //last element
