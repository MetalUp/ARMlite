// Define & initialise registers
      MOV R0, #arrayData //Address of array data
      LDR R1, arrayLength  
      LSL R1, R1, #2  //Multiply this by 4 (for byte count)
      MOV R2, #0   //outerLoop counter initialized
      // R3   innerLoop counter
      // R4 length of innerLoop
      // R5 working pointer into array
      // R6 first in pair
      // R7 second in pair
      // R8 If any pair swapped on this pass (of inner loop) 
// Start of outer loop 
      MOV R3, #0  //start inner loop counter at zero
      MOV R4, R1  
      SUB R4, R4, R2  //set innerloop max to  data length - outerLoopCounter...
      SUB R4, R4, #4  //...minus 4 more
      MOV R8, #0  //reset swapped      
innerLoop:
      MOV R5, R0
      ADD R5, R5, R3
      LDR R6, [R5]  //first value
      LDR R7, [R5+4] //second value (this syntax is convenient here!)
      CMP R6, R7
      BGT swap
      B continueInnerLoop
swap: 
      STR R7, [R5]
      STR R6, [R5 + 4]
      MOV R8, #1  //Flag that a swap has taken place
continueInnerLoop:
      ADD R3, R3, #4
      CMP R3, R4
      BLT innerLoop
continueOuterLoop:
      CMP R8, #0
      BEQ done  //Terminate if nothing swapped in last inner loop pass
      ADD R2, R2, #4 
      CMP R2, R1
      BGT done
      B startOfOuterLoop
done: HALT

.ALIGN 256 //Just to make data distinct from code in memory view
arrayLength: 10 
arrayData:.WORD 9  //1st element
      .WORD 8
      .WORD 7
      .WORD 6
      .WORD 5
      .WORD 4
      .WORD 3
      .WORD 2
      .WORD 1
      .WORD 0  //last element
