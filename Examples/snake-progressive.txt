//Define registers 
      // R0-2 reserved for temporary uses
      // Global variables:
      // R3 Tail position
      // R4 Head position
      // R7 ASCII value of last key pressed 
      // Constants:
      MOV R10,#.PixelScreen
      MOV R11, #.green //Colour of snake

//Set up interrupts - but don't enable yet
      MOV R0, #update
      STR R0, .ClockISR
      MOV R0, #0x50
      STR R0,.ClockInterruptFrequency
      MOV R0, #keyPress
      STR R0, .KeyboardISR
      MOV R0, #1
      STR R0, .KeyboardMask

//Initialise game
      MOV R3, #1084    //Initialise tail and ...
      MOV R4, #1088    //Head next to it (4 bytes = 1 word = 1 pixel)
      STR R11,[R3+R10] //Draw 2-segment snake
      STR R11,[R4+R10] 
      MOV R0, #1
      STR R0, .InterruptRegister //Now we are ready to handle interrupts

mainLoop: b mainLoop //Just keeps the processor running, pending interrupts

//Interrupt driven
update:
      //Switch on direction of last key
      CMP R7,#87 //W key
      BEQ up
      CMP R7,#65 //A key
      BEQ left
      CMP R7,#83 //S key
      BEQ down
      // By default the snake will move right

right:ADD R4,R4,#4   //+4 (bytes) moves right one pixel
      B reDraw
down: ADD R4,R4,#256 //+64*4 moves down one row
      B reDraw
up:   SUB R4,R4,#256 //-64*4 moves up one row
      B reDraw
left: SUB R4,R4,#4   //-4 moves left one pixel
reDraw: 
      STR R11,[R4+R10] //Draw new head
      RFE

//Called by keyboard interrupt
//If valid key (W,A,S,D) has been pressed, transfer this to R7
keyPress: PUSH {R0}
      LDR R0,.LastKey //Read the last key pressed (but don't wait for one)
      CMP R0,#87 //W key
      BEQ updateLastKey
      CMP R0,#65 //A key
      BEQ updateLastKey
      CMP R0,#83 //S key
      BEQ updateLastKey
      CMP R0,#68 //D key
      BEQ updateLastKey
      B .+2 //If not a valid new key don't change last key
updateLastKey:
      MOV R7, R0
      POP {R0}
      RFE