defineRegisters: 
      // R0 used for many temporary purposes
      // R1 used for colours
      mov r2,#.PixelScreen
      mov r3, #1084 //Tail position, initialised
      mov r4, #1088 //Head position, initialised
      mov r5, #0 //Apple position
      mov r6, #body //Pointer front of queue, initialised to first data loc
      add r7,r6,#4 //Pointer to head address in body data (1 after tail)
      mov r9, #0 //ASCII value of last key pressed
      mov r10, #12284 //Constant - the last screen memory offset
      mov r11, #4092 //Constant for masking
      mov r12, #68 //Current direction of movement, initialised to 'right'

InitialisePointers:
      str r3, [r6] //r4 points to the tail address
      str r4, [r7] //r3 points to the head address
drawSnake:
      mov r1, #.green
      str r1,[r3+r2] //Tail
      str r1,[r4+r2] //Head
createApple:
      ldr r5,.Random // gets a random 32 bit pattern
      and r5,r5,r11 // r11 has 1023*4
      cmp r5,r10 // r10 has 767*4
      bgt createApple // restrict random range
      cmp r5,r4 // Make sure apple is not located on head of snake
      beq createApple 
moveSnake:
      mov r1, #.red
      str r1,[r5+r2] //Draw Apple each cycle, in case it is on snake
      ldr r9,.LastKey //Read the last key pressed (but don't wait for one)
switchOnKey:
      cmp r9,#87 //W key
      beq up
      cmp r9,#65 //A key
      beq left
      cmp r9,#83 //S key
      beq down
      cmp r9,#68 //D key
      beq right
dontChangeDirection:
      mov r9, r12 //If not any of the recognised keys, use prev direction
      b switchOnKey //and re-run the switch on key
right:
      cmp r12,#65
      beq dontChangeDirection
      add r4,r4,#4 //Adding 1*4 to location moves right
      and r0,r4,#252
      cmp r0,#0
      beq gameOver
      b reDraw
down:
      cmp r12,#87
      beq dontChangeDirection
      add r4,r4,#256 //64*4 moves down one row on screen
      cmp r4,r10
      bgt gameOver
      b reDraw
up:
      cmp r12,#83
      beq dontChangeDirection
      sub r4,r4,#256 //-64*4 moves up one row on screen
      cmp r4,#0
      blt gameOver
      b reDraw
left: 
      cmp r12,#68
      beq dontChangeDirection
      sub r4,r4,#4 //-1 moves left
      and r0,r4,#252
      cmp r0,#252
      beq gameOver
      b reDraw
reDraw: 
      mov r12,r9 //Update current direction with latest key
      cmp r4,r5 //If the head is in same location as apple...
      beq moveHead //...Skip updating the tail, to make snake grow
moveTail:
      ldr r0, [r6]
      mov r1, #.white
      str r1,[r0+r2] //Reset tail to Background
      add r6,r6,#4 //Increment the tail pointer (for use next cycle)
      cmp r6,#1024 //Check pointer is still within memory
      blt moveHead
      mov r6, #body //If not loop pointer back to start of body data
moveHead:
      add r7,r7,#4 //Increment the head pointer
      cmp r7,#1024 //Check pointer is still within memory
      blt updatePointer
      mov r7, #body //If not loop pointer back to start of body data
updatePointer:
      str r4, [r7] //Store the new head location in data
checkForCrossing: // check if the snake has hit itself
      ldr r0,[r4+r2] // read, from screen, colour of pixel head is moving to
      cmp r0,#.green //If it is snake colour ï¿½
      beq gameOver
checkForMaxLength:
      cmp r6,r7 //If the front has caught up with rear, then body data full
      beq gameWin 
      mov r1, #.green
      str r1,[r4+r2] //Draw new head
      cmp r4, r5 //Check again if the apple was eaten this cycle
      beq createApple //If so, loop back to creating the apple
      b moveSnake /Otherwise just repeat the move cycle
gameWin:
      mov r0, #message
      str r0,.WriteString //Write message as text into output window
gameOver:
      halt //To stop program execution running into data area
message: .ASCIZ " You Win"
body: dat 0 //Initial front of queue (screen address for tail)
