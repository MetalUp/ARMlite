      //Define registers 
      // R0 used for many temporary purposes
      // R1 used for colours
      MOV r2,#.PixelScreen
      MOV r3, #1084 //Tail position, initialised
      MOV r4, #1088 //Head position, initialised
      MOV R5, #body //Pointer front of queue, initialised to first data loc
      ADD R6,R5,#4 //Pointer to head address in body data (1 after tail)
      MOV r9, #68 //ASCII value of last key pressed initialised to D for eastward movement
      MOV R10, #0 //Apple position
      MOV r11, #0

//Set up interrupts - but don't enable yet
      MOV R0, #updatePositions
      STR R0, .ClockISR
      MOV R0,#0x21
      STR R0,.ClockInterruptFrequency
      MOV R0, #keyPress
      STR R0, .KeyboardISR
      MOV R0, #1
      STR R0, .KeyboardMask

// Initialise game
      STR r3, [R5] //r4 points to the tail address
      STR r4, [R6] //r3 points to the head address
      MOV r1, #.green  //Draw 2-segment snake in initial position
      STR r1,[r3+r2]
      STR r1,[r4+r2] 
      bl createApple
      STR R0, .InterruptRegister  //Now we are ready to handle interrupts

mainLoop: b mainLoop //Just keeps the processor running, pending interrupts

//Called by clock interrupt
updatePositions:
      push {}
      MOV r1, #.red
      STR r1,[R10+r2] //Draw Apple each cycle, in case it is on snake
//Switch on direction of last key
      CMP R9,#87 //W key
      BEQ up
      CMP R9,#65 //A key
      BEQ left
      CMP R9,#83 //S key
      BEQ down
      CMP R9,#68 //D key
      BEQ right //Not strictly necessary, but written for consistency
right:ADD R4,R4,#4 //+4 (bytes) moves right 1 pixel
      AND R0,R4,#256
      CMP R0,#256
      BEQ gameOver
      B reDraw
down: ADD R4,R4,#256 //+64*4 moves down one row
      MOV R0, #12284
      CMP R4,R0
      BGT gameOver
      B reDraw
up:   SUB R4,R4,#256 //-64*4 moves up one row
      CMP R4,#0
      BLT gameOver
      B reDraw
left: SUB R4,R4,#4 //-4 moves left 1 pixel
      AND R0,r4,#252
      CMP R0,#252
      BEQ gameOver
      B reDraw  //Not strictly necessary, but added for consistency
reDraw: 
      CMP R4,R10 //If the head is in same location as apple...
      BNE moveTail
      ADD r11,r11,#1 //Increment snake length (for scoring)
      B moveHead //...Skip updating the tail, to make snake grow
moveTail:
      ldr r0, [R5]
      MOV r1, #.white
      STR r1,[r0+r2] //Reset tail to Background
      ADD R5,R5,#4 //Increment the tail pointer (for use next cycle)
      cmp R5,#1024 //Check pointer is still within limits
      blt moveHead
      MOV R5, #body //If not loop pointer back to start of body data
moveHead:
      ADD R6,R6,#4 //Increment the head pointer
      cmp R6,#1024 //Check pointer is still within limits
      blt updatePointer
      MOV R6, #body //If not loop pointer back to start of body data
updatePointer:
      STR r4, [R6] //Store the new head location in data
// check if the snake has hit itself
      ldr r0,[r4+r2] // read, from screen, colour of pixel head is moving to
      cmp r0,#.green //If it is snake colour
      beq gameOver
checkForMaxLength:
      cmp R5,R6 //If the front has caught up with rear, then body data full
      beq gameWin 
      MOV r1, #.green
      STR r1,[r4+r2] //Draw new head
      cmp r4, R10 //Check again if the apple was eaten this cycle
      bne .+2 //If no apple eaten, exit routine
      bl createApple
      pop {}
      rfe

//Called by keyboard interrupt
//If valid key (W,A,S,D) has been pressed, transfer this to R9
keyPress: push {r0, lr}
      ldr r0,.LastKey //Read the last key pressed (but don't wait for one)
      cmp r0,#87 //W key
      beq updateLastKey
      cmp r0,#65 //A key
      beq updateLastKey
      cmp r0,#83 //S key
      beq updateLastKey
      cmp r0,#68 //D key
      beq updateLastKey
      b .+2  //If not a valid new key don't change last key
updateLastKey:
      MOV r9, r0
      pop {r0, lr}
      rfe


//Generates random valid pixel position in R10
createApple: push {R0, LR}
newRandom:      LDR R10,.Random // gets a random 32 bit pattern
      MOB R0, #0x3ffc // Limit random to 14 bits (just larger than max pixel number)
      AND R10,R10,R0 
      MOV R0, #12284 //Max pixel number
      CMP R10,R0
      BGT newRandom //'Throw again'
      CMP R10,R4 // Make sure apple is not located on head of snake
      BEQ newRandom 
      POP {R0, LR}
      RET

//Finally...
gameWin: 
      MOV r0, #win
      b .+2
gameOver: MOV R0, #over
      STR R0,.WriteString
      MOV R0, #score
      STR R0,.WriteString
      STR r11, .WriteSignedNum
      HALT //To stop program execution running into data area
over: .ASCIZ " Game Over!\n"
score: .ASCIZ "Your score: "
win: .ASCIZ "You Win!"
body: //The 'queue' of body segments from here onwards
