defineRegisters: 
      mov r1,#.green //Snake colour (green)
      mov r2,#.white //Background colour (white)
      mov r3, #1084 //Tail position, initialised
      mov r4, #1088 //Head position, initialised
// note pixel addresses now go up in 4's not 1's and the screen is 32x24
      mov r5, #0 //Apple position
      mov r6, #.red //Apple colour
      mov r7, #body //Pointer front of queue, initialised to first data loc
      add r8,r7,#4 //Pointer to head address in body data (1 after tail)
      mov r9, #0 //ASCII value of last key pressed
      mov r10, #3068 //Constant - the last screen memory offset
      mov r11, #4092 //Constant for masking
      mov r12, #68 //Current direction of movement, initialised to 'right'
      mov lr,#.PixelScreen
InitialisePointers:
      str r3, [r7] //r4 points to the tail address
      str r4, [r8] //r3 points to the head address
drawSnake:
      str r1,[r3+lr] //Tail
      str r1,[r4+lr] //Head
createApple:
      ldr r5,.Random // gets a random 32 bit pattern
      and r5,r5,r11 // r11 has 1023*4
      cmp r5,r10 // r10 has 767*4
      bgt createApple // restrict random range
      cmp r5,r4 // Make sure apples is not located on head of snake
      beq createApple 
moveSnake:
      str r6,[r5+lr] //Draw Apple each cycle, in case it is on snake
      ldr r9,.LastKey //Read the last key pressed (but don�t wait for one)
switchOnKey:
      cmp r9,#87 //W key
      beq up
      cmp r9,#65 //A key
      beq left
      cmp r9,#83 //S key
      beq down
      cmp r9,#68 //D key
      beq right
dontChangeDirection:
      mov r9, r12 //If not any of the recognised keys, use prev direction
      b switchOnKey //and re-run the switch on key
right:
      cmp r12,#65
      beq dontChangeDirection
      add r4,r4,#4 //Adding 1*4 to location moves right
      and r0,r4,#124
      cmp r0,#0
      beq gameOver
      b reDraw
down:
      cmp r12,#87
      beq dontChangeDirection
      add r4,r4,#128 //32*4 moves down one row on screen
      cmp r4,r10
      bgt gameOver
      b reDraw
up:
      cmp r12,#83
      beq dontChangeDirection
      sub r4,r4,#128 //-32*4 moves up one row on screen
      cmp r4,#0
      blt gameOver
      b reDraw
left: 
      cmp r12,#68
      beq dontChangeDirection
      sub r4,r4,#4 //-1 moves left
      and r0,r4,#124
      cmp r0,#124
      beq gameOver
      b reDraw
reDraw: 
      mov r12,r9 //Update current direction with latest key
      cmp r4,r5 //If the head is in same location as apple...
      beq moveHead //...Skip updating the tail, to make snake grow
moveTail:
      ldr r0, [r7]
      str r2,[r0+lr] //Reset tail to Background
      add r7,r7,#4 //Increment the tail pointer (for use next cycle)
      cmp r7,#1024 //Check pointer is still within memory
      blt moveHead
      mov r7, #body //If not loop pointer back to start of body data
moveHead:
      add r8,r8,#4 //Increment the head pointer
      cmp r8,#1024 //Check pointer is still within memory
      blt updatePointer
      mov r8, #body //If not loop pointer back to start of body data
updatePointer:
      str r4, [r8] //Store the new head location in data
checkForCrossing: // check if the snake has hit itself
      ldr r0,[r4+lr] // read, from screen, colour of pixel head is moving to
      cmp r0,r1 //If it is snake colour �
      beq gameOver
checkForMaxLength:
      cmp r7,r8 //If the front has caught up with rear, then body data full
      beq gameWin 
      str r1,[r4+lr] //Draw new head
      cmp r4, r5 //Check again if the apple was eaten this cycle
      beq createApple //If so, loop back to creating the apple
      b moveSnake /Otherwise just repeat the move cycle
gameWin:
      mov r0, #message
      str r0,.WriteString //Write message as text into output window
gameOver:
      halt //To stop program execution running into data area
message: //ASCII encoding of 'You win' message (in reverse)
      dat 0x20756f59 //' uoY'
      dat 0x006e6977 //'niw'
body: dat 0 //Initial front of queue (screen address for tail)
